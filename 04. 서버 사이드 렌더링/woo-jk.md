# 4.1 서버 사이드 렌더링이란?

## 4.1.1 싱글 페이지 애플리케이션의 세상

### 싱글 페이지 애플리케이션이란?

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식
- 최초에 첫 페이지에서 데이터를 모두 불러온 이후 서버에서 더 이상 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리한다.
    - 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 `history.pushState` 와 `history.replaceState` 로 이뤄진다.
- 초기 리소스가 커지지만 사용자에게 훌륭한 UI/UX를 제공한다.

### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

- 이전에는 자바스크립트는 웹에서 사용자에게 추가적인 경험을 주기 위한 보조적인 수단이었다.
- 그러나 자바스크립트 모듈화와 사용자 기기 성능 향상, 인터넷 속도 발전 등으로 웹에서 자바스크립트가 할 수 있는 일이 많아졌다.
- 이러한 변화 덕분에 Backbone.js, AngularJS 등이 등장하면서 자바스크립트에서도 어느 정도 서버에서만 할 수 있는 복잡한 작업을 할 수 있게 되었다.
- 이후 React, Vue, Angular 시대가 오면서 웹 앱에서 자바스크립트 역할은 더욱 커졌고, 렌더링부터 인터랙션까지 자바스크립트로 모두 아우를 수 있는 싱글 페이지 렌더링 방식이 인기를 얻게됐다.
- 과거 웹 개발은 LAMP(Linux, Apache, MySQL, PHP/Python) 구조가 인기 있었지만, 웹 앱의 확장성에 걸림돌로 작용했다.
- 그래서 JAM(JS, API, Markup) 스택이 등장했고, 자바스크립트와 마크업을 빌드해두고 사용자에게 제공하면서 서버 확장성 문제에서 좀 더 자유로워질 수 있게 됐다.

### 새로운 패러다임의 웹서비스를 향한 요구

- 시간이 갈수록 웹 앱에서 하는 작업이 많아지고 자바스크립트 리소스의 크기가 증가했다.
- 이로인해 사용자가 상호작용할 수 있을 때까지 대기하는 시간이 매우 길어졌다.
- 과거에는 인터넷 속도의 발전이 이 문제를 해결해줄 것이라 생각했지만, 인터넷 속도의 발전보다 웹 앱의 발전이 훨씬 빨랐다.

## 4.1.2 서버 사이드 렌더링이란?

- 싱글 페이지 애플리케이션은 자바스크립트 번들에서 렌더링을 담당하지만 서버 사이드 방식은 서버에서 렌더링을 수행한다.
- 클라이언트 렌더링은 사용자 기기의 성능에 영향을 받지만 서버 사이드 렌더링은 서버에서 제공하기 때문에 비교적 안정적인 렌더링이 가능하다.

### 서버 사이드 렌더링의 장점

- 최초 페이지 진입이 비교적 빠르다
    - CSR에서는 HTTP API 요청이 필요한 페이지의 경우, 자바스크립트를 다운로드하고, 초기 렌더링 하고, HTTP 요청을 수행하고, 응답 받는 과정을 거쳐야 원하는 화면을 렌더링 할 수 있다.
    - 반면에 SSR은 이 작업이 서버에서 일어난다면 일부 과정을 생략할 수도 있고, 더 빠르고 안정적으로 실행된다.
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다
- 누적 레이아웃 이동이 적다
    - 누적 레이아웃 이동(Cumulative Layout Shift)란, 페이지를 보여준 이후 뒤늦게 HTML 정보가 추가되어 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.
- 사용자의 디바이스 성능에 비교적 자유롭다
- 보안에 좀 더 안전하다
    - 웹에서 일어나는 작업을 쉽게 파악할 수 있는 CSR과 달리, SSR은 작업의 결과물만 사용자에게 보여주기 때문에 보안 위협을 피할 수 잇다.

### 서버 사이드 렌더링의 단점

- 소스코드를 작성할 때 항상 서버를 고려해야 한다
    - window나 localStorage 같이 브라우저에만 있는 전역 객체의 경우 서버에서 사용이 불가능하므로 클라이언트에서 사용해야 한다.
    - 라이브러리도 마찬가지로 서버에 대한 고려가 되어있지 않으면 서버에서 실행이 불가능할 확률이 높다.
- 적절한 서버가 구축돼 있어야 한다
    - CSR은 브라우저에 JS 리소스만 제공하는 역할만 하면 된다.
    - 그러나 SSR은 사용자 요청을 받아 렌더링을 수행할 서버가 필요하다.
- 서비스 지연에 따른 문제
    - SPA의 경우, 무언가 느린 작업이 수행될 때 ‘로딩 중’과 같은 진행 상태를 적절히 안내하기 쉽다.
    - 반면 SSR의 경우 페이지 렌더링이 완료되기 까지 사용자에게 어떤 정보도 제공할 수 없다.

## 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

### 서버 사이드 렌더링 역시 만능이 아니다

- 잘못된 웹페이지 설계는 오히려 성능을 해칠수 있을 뿐만 아니라, 서버와 클라이언트 두 군데로 관리 포인트만 늘어나는 역효과를 낳을 수 있다.
- 웹페이지 설계와 목적, 그리고 우선순위에 따라 싱글 페이지 애플리케이션이 더 효율적일 수 있다.

### SPA를 알아야 하는 이유

- 가장 뛰어난 SPA는 가장 뛰어난 MPA 보다 낫다.
- 이미지 게으른 로딩, 코드 스플리팅 등 SPA의 단점을 상쇄하기 위한 최적화를 거칠 수 있다.
- 브라우저 API와 자바스크립트를 활용한 라우팅을 기반으로한 매끄러운 UX와 성능은 SPA에서만 보여줄 수 있다

### SSR을 알아야 하는 이유

- 일반적으로 SPA는 최적화를 하지 않으면 MPA보다 느리다.
- 또한, 최근에는 MPA에서 발생하는 라우팅 문제를 해결하기 위한 다양한 API가 브라우저에 추가되고 있다.
    - 페인트 홀딩: 같은 출처에서 라우팅이 일어날 경우 화면을 하얗게 띄우는 대신 이전 페이지를 보여주는 기법
    - back forward cache: 브라우저 앞으로 가기, 뒤로 가기 실행 시 캐시된 페이지를 보여주는 기법
    - Shared Element Transitions: 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법
- 같은 노력으로 더 좋은 사용자 경험을 위해선 SPA보단 MPA가 더 나은 경험을 제공한다.

# 4.2 서버 사이드 렌더링을 위한 리액트 API 알아보기

- 기본적으로 리액트는 브라우저 자바스크립트 환경에서 렌더링할 수 있는 방법을 제공한다.
- 그러나 node.js와 같은 서버 환경에서 렌더링할 수 있는 API도 제공한다.
- 리액트에서 SSR을 실행할 때 사용되는 API를 확인해 보려면 리액트 저장소의 `react-dom/server.js` 를 확인하면 된다.

## 4.2.1 renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- 리액트 훅이나 이벤트 핸들러처럼 클라이언트에서 실행되는 자바스크립트 코드는 결과물에 포함되지 않는다.
- 리액트의 서버 사이드 렌더링은 단순히 최초 HTML 페이지를 빠르게 그려주는데에 목적이 있다.
- `data-reactroot` 속성을 통해 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별한다.

## 4.2.2 renderToStaticMarkup

- `renderToString` 함수와 유사하지만, `data-reactroot` 와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다는 차이점이 있다.
- 이 함수로 렌더링한다면 hydrate가 불가능하므로 훅이나 브라우저 API를 실행할 수 없다.
- 즉, 순수한 HTML을 만들 때만 사용된다.

## 4.2.3 renderToNodeStream

- `renderToString` 함수의 결과물과 동일하지만, 두 가지 차이점이 있다.
    1. `renderToString` 은 브라우저에서 실행할 수 있지만, `renderToNodeStream`는 브라우저에서 실행하지 못한다. 
    2. `renderToString` 의 결과물은 문자열 타입이지만, `renderToNodeStream` 은 node.js의 `ReadableStream` 이다. `ReadableStream` 은 utf-8로 인코딩된 바이트 스트림으로 node.js와 같은 서버 환경에서만 사용할 수 있다.

### ReadableStream을 사용하는 이유

- 문자열의 경우 크기가 매우 클 경우 서버에서 큰 부담이 될 수 있다.
- 대신 ReadableStream을 사용하면 큰 크기의 데이터를 청크 단위로 분리해 순차적으로 처리할 수 있다는 장점이 있다.

## 4.2.4 renderToStaticNodeStream

- `renderToNodeStream`과 제공하는 결과물은 동일하나, `renderToStaticMarkup`과 마찬가지로 리액트에 필요한 리액트 속성이 제공되지 않는다.

## 4.2.5 hydrate

- 앞서 살펴본 `renderToString`과 `renderToNodeStream`으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
- `hydrate` 로 넘겨준 두 번째 인자에는 이미 렌더링된 정적인 HTML 정보가 담겨있어야 한다.
- 만약 인수로 넘겨받은 HTML 정보와 hydrate가 수행한 렌더링 결과물 HTML과 비교하여 불일치한다면 hydrate가 렌더링한 기준으로 웹페이지를 그린다.

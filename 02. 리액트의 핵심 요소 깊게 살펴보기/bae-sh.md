# 2. 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX란?

- JSX는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않는 독자적인 문법이다
- JSX는 ECMAScript라고 불리는 자바스크립트 표준이 아니기에 바로 실행할 수는 없다.
- JSX는 페이스북이 만든 새로운 문법이고 이를 실행하기 위해 트랜스파일러를 거쳐야 런타임이 이해할 수 있는 코드로 변환된다.
- JSX는 XML 스타일의 트리구문을 작성하는데 도움을 주는 문법이다. 이 트리구조를 토큰화 하여 ECMAScript로 변환된다.

### 2.1.1 JSX의 정의

### JSXElement

- JSX를 구성하는 가장 기본적인 요소
- JSXOpeningElement, JSXClosingElement, JSXSelfClosingElement, JSXFragment 등으로 구성되어있다. (자세하게 알필요는 없을것 같다)
- 리액트에서는 유저가 만든 컴포넌트와 시멘틱태그를 구분하기 위해 대소문자로 구분한다

### JSXElementName

- JSXElement의 요소이름을 쓸 수 있는것을 의미
- JSXIdentifier: 식별할 수 있는 규칙같은것. 가장 기본을 의미함 **($,_ 외의 다른 특수문자는 시작할 수 없음)**
- JSXNamespacedName: `:` 로 연결하여 JSXIdentifier 와 JSXIdentifier 를 연결
    - ex) <foo:bar></foo:bar>
- JSXMemberExpression:  `.` 로 연결하여 식별자를 연결함
    - ex) <foo.bar></foo/bar>
    
    → JSXNamespacedName 와 JSXMemberExpression 는 리액트에서 사용하지 않음
    

### JSXAttributes

- JSXElement에 부여할 수 있는 속성. 필수값이 아니여서 존재하지 않아도 됨
- JSXSpredAttributes: 자바스크립트의 전개 연산자와 같은것
    - Ex) {…AssignmentExpression}

### JSXChildren

- JSXElement의 자식값을 나타낸다.
- JSX는 속성을 가진 트리구조를 나타내기에 JSX로 부모 자식 관계를 나타낼 수 있다.

### JSXStrings

- 큰따옴표, 작은따옴표로 구성된 문자열 혹은 JSXText를 의미.

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- @babel/plugin-transform-react-jsx 플러그인이 변환을 도와준다.
- 이전 트랜스파일 결과값과 바벨7.9.0 이후 버전에 추가된 자동런타임 으로 트랜스파일 한 결과는 다르다. (자세한 것은 8장 이후)
    - runtime 옵션에 ‘automatic’
- JSXElement를 첫번쨰 인수로 선언해 요소를 정의
- 옵셔널 값들 (JSXChildren, JSXAttributes, JSXStrings) 는 이후 인수로 넘겨주어 처리한다
    - 이러한 문법 때문에 JSX에서는 무조껀 부모로 감싸져 있어야함

### 2.1.4 정리

- JSX는 리액트보다 넓은 개념이다. 리액트에는 JSX의 모든 구문을 활용하지는 않는다.

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

- DOM은 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고있다.
- 브라우저는 유저의 눈에 보이는 노드만 방문한다.

### 2.2.2 가상 DOM의 탄생 배경

- 단순 색상 변경 → 페인팅이 발생한다. 만약 노출여부 및 사이즈가 변경되면 레이아웃 이 발생하고 리페인팅이 발생
- 싱글페이지의 경우 HTML을 새로받는것이 아니라 하나의 페이지에서 요소를 다시 계산하고 반영한다.
- 유저의 상호작용 모든 DOM의 과정을 추적하는 것은 피곤한 일. 결과만 알기위해 나타난 것이 가상 DOM.
- react-dom은 웹페이지에 반영될 것을 메모리에 저장하고 적절한 타이밍에 실제 DOM에 반영한다.
- 가상DOM이 일반적인 DOM보다 빠르다는 것은 잘못된 편견(오히려 느리다. 하지만 왠만한 프로젝트에 커버가 가능)

### 2.2.3 가상 DOM을 위한 아키텍쳐, 리액트 파이버

### 파이버

- 가상 DOM과 렌더링과정 최적화 기능을 해주는 것이 리액트 파이버
- 가상 DOM과 실제 DOM의 변경사항을 저장하고 렌더링 요청하는 역할
- 과거 리액트는 스택 자료구조를 사용하여 동기적으로 작업이 이루어짐 → 현재는 파이버로 비동기적으로 작업을 효율적으로 함
- 파이버는 하나의 작업단위로 구성되어 있다.
- 리액트 요소와 파이버의 차이점은 리액트의 경우 랜더링 시 새롭게 생성되지만, 파이버는 가급적 재사용 된다.
- 파이버는 하나의 element에 하나가 생성되는 1:1 관계를 가진다. 이 매칭 정보를 tag가 가지고 있다.( 함수컴포넌트인지, 클래스컴포넌트 인지 등등 어떤 타입인지를 저장)
- 파이버는 children이 아닌 child이며, 하나의 자식만을 가질 수 있다. (하나의 자식과 그 자식은 형제를 가짐)
- 이러한 파이버들은 state변경, 생명주기 메서드 실행, DOM 변경 등 변경이 필요한 시점에 실행되고 미루거나 빠르게 처리하거나 유연하게 가능
- 리액트의 핵심원칙은 UI를 값으로 관리한다는 것.

### 파이버 트리

- 리액트 내부에 2개가 존재하며, 하나는 현재 모습이고 다른 하나는 변경 될 모습이다.
- WorkingInProgress 작업이 끝나면 포인터를 변경하며 이러한 기술을 `더블 버퍼링`이라고 한다.
- 파이버의 작업순서
    1. beginWork()를 통해 파이버 작업 실행
    2. completeWork()를 통해 파이버 작업 완료
    3. 형제가 있다면 이동
    4. 모두 끝나면 return
- 처음 렌더링 될 경우에 파이버를 생성해야 하지만 그 이후 변경하는 것은 기존의 것에서 Props만 변경해서 만든다.(재활용 극대화)

### 2.2.4 파이버와 가상 DOM

- 실제 브라우조 구조에 반영하는 것은 동기적으로 이루어 져야한다.
- 가상 DOM은 브라우저에만 존재하기에 파이버와 동일한 개념이 아니다. (리액트 네이티브도 파이버로 렌더를 조정하는 것은 맞다)

### 2.2.5 정리

- 결국 리액트는 빠르게 DOM을 그리는 것이 목적이 아닌, UI를 값으로 관리하여 효율적으로 작동하는 것이 핵심

## 2.3 클래스형 컴포넌트와 함수 컴포넌트

- 함수형 컴포넌트는 원래 정적으로 렌더링 하는 컴포넌트였다.

### 2.3.1 클래스형 컴포넌트

- constructor: 생성자 함수가 존재하면 컴포넌트가 초기화 되는 시점에 호출
- props: 컴포넌트에 특정 속성을 전달하는 용도로 사용
- state: 클래스형 컴포넌트 내부에서 관리하는 값을 의미
- 메소드: this를 바인딩 하기, 화살표 함수 쓰기(상위 스코프 결정되기에 바인딩 할필요 없음)

### 클래스형 컴포넌트의 생명주기 메서드

- 마운트 : 컴포넌트 생성 시점
- 업데이트: 컴포넌트 내용 변경 시점
- 언마운트: 컴포넌트가 존재하지 않는 시점
- render: 생명주기 메소드 하나로 유일한 필수 값이다. 순수함수이어야 한다.
- componentDidMount: 컴포넌트가 마운트 되고 즉시 실행된다. 이 함수는 UI 업데이트 전에 실행되어 유저는 변경되는 것을 눈치챌 수 없다.
- componentDidUpdate: 컴포넌트 업데이트 이후 실행. state, props의 변화에 따라 DOM을 업데이트
- componentWillUnmount: 컴포넌트가 언마운트 되기 직전에 실행 Ex) 이벤트 지우기, API 호출 취소
- shouldComponentUpdate: 상태가 변하여도 컴포넌트를 업데이트 시키지 않을 수 있다.
- static getDerivedStateFromProps: render 호출 직전에 호출.static으로 선언되어 있어 this에 접근이 불가능 하다. 모든 render 실행 시 호출 된다.
- getSnapShotBeforeUpdate: Dom이 업데이트 되기 직전에 사용 ex) 윈도우 크기 조절, 스크롤 위치 조정
- getDerivedStateFromError: 자식 컴포넌트에서 에러 발생 시 호출되는 메서드
- componentDidCatch: getDerivedStateFromError 이후 상태가 결정되고 그 뒤에 실행

→ 위 두개의 메서드는 ErrorBoundary를 설정하여 에러를 핸들링 할 수 있다.

→ 개발모드에서는 componentDidCatch 함수의 에러도 window에서 잡을 수 있지만, 프로덕션 환경은 componentDidCatch에 잡으면 window까지 가지 않는다.

→ displayName을 작성함으로써 componentStack의 추적을 용이하게 한다

### 클래스형 컴포넌트의 한계

- 데이터 흐름 추척 힘듬
- 로직의 재사용성 낮음
- 보일러 블레이트가 많음
- 번들링을 최적화 하기 힘들다.
- 핫리로딩이 힘들다( 코드가 변경되면 상태가 다시 처음부터 초기화)

### 2.3.3 함수형 컴포넌트 vs 클래스형 컴포넌트

1. 함수형에는 생명주기 메서드가 존재하지 않는다. (완전히 똑같지는 않다)
2. 함수형 컴포넌트는 렌더링된 값을 고정한다.(클래스형은 현재의 this값을, 함수형은 당시의 this값을 사용)

## 2.4 렌더링은 어떻게 일어나는가?

- 리액트에서 렌더링이란, 브라우저가 렌더링에 필요한 DOM을 그리는 과정

### 2.4.1 리액트의 렌더링이란?

- 현재 컴포넌트의 props와 state를 기반으로 어떻게 화면에 그릴 DOM을 계산하고 브라우저에 제공할것인가에 대해 계산하는 과정

### 2.4.2 리액트의 렌더링이 일어나는 이유

- 최초 렌더링: 첫 어플리케이션 진입 시 화면을 제공하는 것
- 리렌더링: 최초 렌더링 이후 발생하는 모든 렌더링
    - setSate 요청(클래스형 컴포넌트)
    - forceUpdate 실행 (클래스형 컴포넌트)
    - useState의 두번째 요소로 실행 (함수형)
    - useReducer의 dispatch 실행 (함수형 컴포넌트)
    - 컴포넌트의 key props가 변경되는 경우
        - 왜 key값을 써야하나? → key는 해당 트리의 형제 컴포넌트를 구별하기 위해서다. 컴포넌트를 식별할때 하나의 자식과 형제노드로 구분을 하는데 순서가 변경되면 의도치 않은 변경이 발생할 수 있음. key를 통해 workingInProgress와 current의 컴포넌트를 비교하기 용이

### 2.4.3 리액트의 렌더링 프로세스

- 렌더링이 발생하면 루트로부터 아래쪽으로 이동하면서 업데이트가 필요한 컴포넌트를 찾고 해당 컴포넌트의 render() or FunctionComponent()을 호출하고 결과를 저장한다
- 이러한 결과들을 수집하고 새로운 DOM에 변경사항을 저장 → 이과정을 리액트의 재조정이라고 한다.

### 2.4.4 렌더와 커밋

- 렌더 단계는 컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업
    
    → 컴포넌트의 return 결과가 이전 DOM이랑 다른가를 체크 ( key, props, type을 확인)
    
- 커밋 단계는 변경사항을 실제 DOM에 적용하여 사용자에게 보여주는 과정
- DOM을 업데이트 이후에는 해당 DOM을 참조하도록 변경. 그 뒤 useLayoutEffect 실행
- **리액트 렌더링이 일어난다고 해서 항상 커밋단계로 가는것은 아님**
- 기본적으로 렌더링은 동기적으로 발생했지만, v18 버전이후에 비동기 렌더링이 발생.

### 2.4.5 일반적인 렌더링 시나리오 살펴보기

- 상태가 변경되면 최상단 트리로부터 렌더링 경로를 검사한다. (변경한 컴포넌트의 자식은 변경사항이 없어도 재렌더링 발생)

### 2.5 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

### 2.5.1 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

- 간단한 함수는 메모리에서 가져오는것 보다 재렌더링이 낫다

### 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자

- 했을떄보다 안했을때 돌아오는 비용이 더 크다.

# 2.1 JSX란?

- JSX는 자바스크립트 내부에서 XML 스타일의 트리 구문을 작성할 수 있게하는 새로운 문법
- 페이스북(현 메타)에서 새롭게 소개한 구문은 맞지만, 리액트에 종속적인 문법은 아니다.
- JSX 자체로는 동작하지 못하고 트랜스파일링을 거쳐 의미있는 자바스크립트 코드로 변환하여 사용할 수 있다.

## 2.1.1 JSX의 정의

### JSXElement

- JSX를 구성하는 가장 기본 요소
- JSXElement의 네이밍 규칙
    - 숫자로 시작하거나 $와 _ 외의 다른 특수문자로 시작할수 없다.
    - 대문자로 시작해야하는 규칙은 `리액트` 에서 HTML 태그명과 구분하기 위한 규칙이다. JSXElement 자체의 네이밍 규칙은 아니다.

### JSXAttributes

- JSXElement에 부여할 수 있는 속성을 의미

### JSXChildren

- JSXElement의 자식 값을 나타낸다.
- JSXChild는 JSXChildren을 이루는 기본 단위이다. JSXChildren은 JSXChild를 0개 이상 가질수 있다.
- JSXChild의 종류는 다음과 같다.
    - JSXText: `{, <, >, }`을 제외한 문자열
    - JSXElement
    - JSXFragment
    - { JSXChildExpression (optional) }: JSXChildEpression은 자바스크립트의 AssignmentExpression을 의미한다.

### JSXStrings

- HTML의 내용(문자열)을 JSX로 쉽게 가져올 수 있도록 정의된 문자열
- 큰따옴표로 구성된 문자열, 작은따옴표로 구성된 문자열, JSXText를 의미

## 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- 리액트에선 `@babel/plugin-transform-react-jsx` 플러그인을 통해 JSX를 변환한다.

```jsx
const ComponentA = <A required={true}>Hello World</A>

const ComponentB = <>Hello World</>

const ComponentC = (
  <div>
    <span>hello world</span>
  </div>
)
```

위 코드를 변환한 결과는 다음과 같다.

```jsx
var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  'Hello World',
)
var ComponentB = React.createElement(React.Fragment, null, 'Hello World')
var ComponentC = React.createElement(
  'div',
  null,
  React.createElement('span', null, 'hello world'),
)
```

# 2.2 가상 DOM과 리액트 파이버

## 2.2.2 가상 DOM의 탄생 배경

- 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다.
- 가상 DOM은 바뀔 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료 됐을 때 실제 브라우저의 DOM에 반영한다.
- DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 거치면서 실제 렌더링 과정을 최소화한다.
- 다만, 가상 DOM 방식이 일반 DOM 변경 방식보다 빠른 것은 잘못 알려진 사실이다.

## 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

### 리액트 파이버란?

- 리액트 컴포넌트에 대한 작업을 나타내는 자바스크립트 객체
- 파이버 재조정자(reconciler)에 의해 관리되고, 이는 가상 돔과 실제 돔을 비교하여 화면에 렌더링하는 역할을 한다.
- 리액트 파이버는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 목표를 가진다.
- 기존의 스택 렌더러에 비하여 파이버 렌더러는 다음과 같은 특징을 가진다.
    - 모든 작업이 비동기로 동작된다.
    - 작업을 작은 단위로 쪼개고, 작업의 우선순위를 매긴다.
    - 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
    - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

### 리액트 파이버 객체의 주요 속성

- tag: 파이버는 하나의 element 당 하나가 생성되는 1:1 관계이다. 해당 파이버와 매칭된 element의 정보를 가진다.
- stateNode: 파이버 자체에 대한 참조 정보를 가진다.
    - 이 참조를 바탕으로 리액트는 파이버와 관련된 상태에 접근한다.
- chlid, sibling, return: 파이버 간의 관계 개념을 나타내는 속성이다.
    - 컴포넌트 트리와 같이 파이버도 트리를 형성하고 있는데, 컴포넌트 트리와 다른 점은 파이버 당 하나의 child만 존재한다.
    - 여러 개의 자식이 있다면, 첫 번째 자식만 child로 연결하고 나머지 자식들과 sibling으로 연결 시킨다.
- index: 여러 형제들(sibling) 사이에서 자신의 위치가 몇 번째인지 숫자로 표현한다.
- pendingProps: 아직 작업을 미처 처리하지 못한 props
- memoizedProps: 렌더링이 완료된 이후 pendingProps를 memoizedProps로 저장해 관리한다.
- updateQueue: 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐
- memoizedState: 함수 컴포넌트의 모든 훅 목록을 저장
- alternate: 반대편 트리 파이버를 가리키는 값

### 리액트 파이버 트리

- 파이버 트리는 리액트 내부에서 두 개가 존재한다.
- 현재 모습을 담은 current 트리와 작업 중인 상태를 나타내는 workInProgress 트리다.
- 작업이 끝나면 포인터만 변경하여 workInProgress 트리를 current 트리로 지정하는데, 이를 `더블 버퍼링` 이라고 한다.

### 파이버의 작업 순서

1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때 까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그다음 completeWork() 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

## 2.2.4 파이버와 가상 DOM

- 가상 DOM이라는 표현은 엄밀히 말하자면 웹 앱에서만 통용되는 개념이다.
- 리액트 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있다.
- 그렇기 때문에 가상 DOM과 파이버는 동일한 개념이 아니다.

## 2.2.5 정리

- 가상 DOM과 파이버는 기존의 브라우저 DOM 변경 작업보다 성능적으로 빠른 작업을 위한 것이 아니다.
- 기존에 개발자가 DOM을 수동으로 하나하나 변경하는 것이 매우 불편하고 파악하기 힘들었던 문제가 있었다.
- 이러한 어려움을 리액트 내부의 파이버와 재조정자가 관리해 줌으로써 효율적으로 대규모 웹 앱을 관리할 수 있게된 것이다.
- 가상 DOM과 리액트의 핵심은 `값으로 UI를 표현`하는 것이다. UI를 값으로 관리하고 이 흐름을 효율적으로 관리하기 위한 메커니즘이 리액트의 핵심이다.

# 2.3 클래스 컴포넌트와 함수 컴포넌트

## 2.3.1 클래스 컴포넌트

### 생명주기 메서드

- render()
    - 컴포넌트가 UI를 렌더링하기 위한 메서드
    - 클래스 컴포넌트의 유일한 필수 값
    - 이 함수는 항상 순수해야 하고, 부수 효과가 없어야 한다.
- componentDidMount()
    - 컴포넌트가 마운트 되고 준비 완료 되었다면 호출되는 메서드
    - 브라우저가 UI를 업데이트하기 전에 실행된다.
    - 하지만 성능 문제가 발생할 수 있으므로 componentDidMount가 반드시 필요한 작업이 아니라면 생성자에서 수행하는 것이 좋다.
- componentDidUpdate()
    - 컴포넌트 업데이트가 일어난 후 호출되는 메서드
    - 무한 this.setState가 일어나지 않도록 주의하는 것이 필요하다
- componentWillUnmount()
    - 컴포넌트가 언마운트 되거나 더 이상 사용되지 않기 직전에 호출되는 메서드
- shouldComponenetUpdate()
    - state나 props가 변경 되었지만, 특정 조건에 따라 리렌더링을 막기 위한 메서드
- static getDerivedStateFromProps()
    - 변경될 props에 따라 현재의 state를 변경하고 싶을 때 사용하는 메서드
    - 이 메서드에서 반환하는 객체의 내용은 state로 들어가게 된다.
    - static으로 선언되어 있기 때문에 this에 접근하지 못한다.
- getSnapShotBeforeUpdate()
    - DOM이 업데이트되기 직전에 호출되는 메서드
    - 이 함수에서 반환되는 값은 componentDidUpdate로 전달된다.
- static getDerivedStateFromError()
    - 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드
    - 반환 값은 반드시 state 값을 반환해야 한다.
    - 또한, 렌더링 과정에서 호출되는 메서드이기 때문에 부수 효과를 발생 시켜서는 안된다.
    - 부수 효과가 필요한 작업은componenetDidCatch를 이용한다.
- componentDidCatch()
    - 자식 컴포넌트에서 에러가 발생했을 때 호출되며, getDerivedStateFromError()에서 에러를 잡고 state를 결정한 이후에 실행된다.
    - 렌더 단계에서 실행되는 getDerivedStateFromError와 다르게 커밋 단계에서 실행된다.
    - 에러 로깅 등 부수 효과 작업을 수행할 수 있다.

### 클래스 컴포넌트의 한계

- 데이터의 흐름을 추적하기 힘들다.
    - 수많은 생명주기 메서드가 있고, 서로 다른 메서드에서 setState가 발생할 수 있으므로 이를 관리하기 힘들다.
- 로직의 재사용이 어렵다.
    - 컴포넌트 간에 중복되는 로직이 있고, 이를 재사용하기 위해선 고차 컴포넌트를 사용해야한다.
    - 그러나 고차 컴포넌트는 래퍼 지옥이라는 심각한 단점이 있다.
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.
    - 자바스크립트 환경에서는 함수에 비해 클래스의 사용이 비교적 어렵고 일반적이지 않다.
    - 대부분의 언어와 다르게 작동하는 this를 비롯한 자바스크립트의 작동 방식은 개발자들에게 큰 혼란을 준다.
- 코드의 크기를 최적화하기 어렵다.
    - 클래스 컴포넌트는 번들링을 최적화하기에 불리한 조건을 갖고 있다.
- 핫 리로딩을 하는 데 상대적으로 불리하다.
    - 핫 리로딩이란, 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법이다.
    - 클래스 컴포넌트는 변경된 코드를 반영하기 위해선 인스턴스를 재생성해야 하기 때문에 내부 상태가 모두 초기화된다.
    - 이로인해 개발자 경험이 좋지 못하다.

## 2.3.2 함수 컴포넌트

- 함수 컴포넌트는 리액트 16.8 버전에 훅이 등장하면서 각광을 받고 있다.
- 클래스 컴포넌트와는 달리 this 바인딩을 조심할 필요없고, state를 객체로 관리할 필요도 없다.
- 그 외에도 다양한 차이점이 존재한다.

## 2.3.3 함수 컴포넌트 vs 클래스 컴포넌트

### 생명주기 메서드의 부재

- 함수 컴포넌트는 생명주기 메서드가 존재하지 않는다.
- useEffect로 생명주기 메서드를 비슷하게 구현할수 있다. 그러나 이는 비슷할 뿐, 동일하다는 것은 아니다.

### 함수 컴포넌트와 렌더링된 값

- 클래스 컴포넌트에서 state와 props의 값은 항상 this로 가져온다.
- 하지만 this가 가리키는 객체, 즉 컴포넌트의 인스턴스 멤버는 변경 가능한(mutable) 값이다.
- 고정되지 않은 this로 인해 개발자가 의도하지 않은 결과가 발생할 수 있다.

# 2.4 렌더링은 어떻게 일어나는가?

## 2.4.1 리액트의 렌더링이란?

- 모든 컴포넌트들의 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 과정

## 2.4.2 리액트의 렌더링이 일어나는 이유

- 최초 렌더링
    - 사용자가 처음 애플리케이션에 진입하면 수행하는 최초 렌더링
- 리렌더링
    - 클래스 컴포넌트의 setState가 실행되는 경우
    - 클래스 컴포넌트의 forceUpdate가 실행되는 경우
    - 함수 컴포넌트의 useState의 setter가 실행되는 경우
    - 함수 컴포넌트의 useReducer의 dispatch가 실행되는 경우
    - 컴포넌트의 key props가 변경되는 경우
        - 파이버 트리에서 컴포넌트 변경을 구별하기 위해 key를 사용한다.
    - props가 변경되는 경우
    - 부모 컴포넌트가 렌더링될 경우

## 2.4.3 리액트의 렌더링 프로세스

1. 컴포넌트의 루트에서부터 시작해 업데이트가 필요하다고 지정된 모든 컴포넌트를 찾는다.
2. 업데이트가 필요한 컴포넌트를 발견하면 클래스 컴포넌트의 경우 render 메서드를, 함수 컴포넌트의 경우 컴포넌트 자체를 호출한 뒤 그 결과물을 저장한다.
3. JSX 결과물을 자바스크립트로 컴파일하면서 React.createElement를 호출하는 구문으로 변환된다.
4. 각 컴포넌트의 결과물을 수집한 다음, 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 수집한다.
5. 위와 같이 계산하는 과정을 리액트의 재조정이라고 하고, 재조정 과정이 모두 끝나면 모든 변경 사항을 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

## 2.4.4 렌더와 커밋

- 렌더 단계
    - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
    - 즉, 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
    - 비교하는 것은 크게 세 가지로, type, props, key이다.
- 커밋 단계
    - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
- 이 때, 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 즉, 렌더 단계가 일어난다고 해서 반드시 커밋 단계로 이어지는 것은 아니다.

# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- 리액트의 메모이제이션 방식으로 useMemo, useCallback, memo 등이 있다.
- 이러한 최적화를 정확히 언제 사용하는지에 대해서는 명확한 답변이 힘들다.
- 메모이제이션에 대한 의견은 리액트 커뮤니티에서 오랜 논쟁 주제 중 하나로, 각 주장을 살펴보고 현명하고 효율적으로 메모이제이션하는 법에 대해 알아보자.

## 2.5.1 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

- 메모이제이션도 어디까지나 비용이 드는 작업이므로 항상 신중해야 한다고 주장한다.
- 메모이제이션은 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다.
- 따라서 메모이제이션은 항상 어느 정도의 트레이드 오프가 있는 기법이라고 봐야한다.
- 일단은 앱을 어느 정도 완성한 이후, 최적화가 필요하다고 생각되는 지점을 측정하고 필요한 곳에만 최적화 하는 것이 옳다.

## 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

- 앞선 주장처럼 필요한 곳에만 최적화를 하는 것이 가장 이상적인 상황이다.
- 그러나 앱의 규모가 커지고, 개발자는 많아지고, 컴포넌트의 복잡성이 증가하는 상황에도 위와 같은 기조를 유지할 수 있을까?
- 따라서 일단 memo로 감싼 뒤에 생각해보는 것이 어떨까?
- memo로 지불하는 비용은 props에 대한 얕은 비교 뿐이다. 물론 이 비용 또한 무시할 수 없고, props가 크고 복잡해지면 이 비용 또한 커질 수 있다.
- 그러나 memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.
    - 렌더링 비용
    - 컴포넌트 내부의 복잡한 로직 재실행
    - 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
    - 리액트가 구 트리와 신규 트리를 비교
- useMemo와 useCallback도 마찬가지로 다음과 같은 문제가 있다.
    - 리렌더링이 발생할 때마다 객체를 재생성하고, 결과적으로 참조가 매번 달라진다.
    - 만약 해당 값이 useEffect와 같은 의존성 배열에 쓰인다면, 참조가 달라지기 때문에 계속해서 useEffect의 콜백이 실행될 것이다.
- 정리하자면, 메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있다. 그러므로 최적화에 확신이 없다면 가능한 모든 곳에서 메모이제이션으로 최적화를 하자.

## 2.5.3 결론 및 정리

- 두 의견 모두 메모이제이션이 리액트에서 할 수 있는 성능 최적화라는 사실에 대해서는 이견이 없다.
- 두 의견 모두 섣불리 정답이라고 할 수는 없다.
- 진행하고 있는 프로젝트의 성격이나 규모, 동료들의 상황 등 여러 요인들을 고려해서 잘 맞는 최적화 방식을 선택하는 것이 중요하다.

# 5장 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?

- 상태란 어떠한 의미를 지닌 값이며 어플리케이션 시나리오에 따라 지속적으로 변경될 수 있는 값 (UI, URL, 폼)
- 애플리케이션 전체적으로 관리해야할 상태는 어디에 둘 것이고 클로저를 만들것인지, 유효범위를 어디에 둘것인지 등등에 대해 고민을 해야한다.

### 5.1.1 리액트 상태 관리의 역사

- Angular와 다르게 리액트는 단순 사용자 UI를 만들기 위한 라이브러리 일 뿐이다. 따라서 상태 관리 방법도 가지각색이다.

### Flux 패턴의 등장

- 리액트에서는 Context API를 통해서 전역 상태 관리를 한다. (엄격히 말하면 상태 주입을 도와주는 역할이라고 한다)
- 기존의 MVC 패턴은 모델과 뷰가 많아질 수록 복잡도가 증가하며 이 원인을 양방향 데이터 바인딩으로 봤다
- 이러한 데이터 흐름을 변경하는것을 제안하는데 이것이 Flux 패턴이다
    - Action → Dispatcher → Model → View
- Action: 어떠한 작업을 처리할 액션과 발생 시 함께 포함시킬 데이터를 의미
- 디스패처: 액션을 스토어에 보내는 역할을 한다.
- 스토어: 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다.
- 뷰 : 리액트의 컴포넌트에 해당하는 부분으로 스토어에서 만들어진 데이터를 가져와 화면을 렌더링 하는 역할을 한다.
- 단방향 데이터 흐름은 사용자의 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트 해야하는 지도 코드로 작성해야하므로 코드 양이 많아진다. 하지만 데이터 흐름 추적하기가 쉽다
- 단방향 데이터 흐름인 리액트와 Flux 패턴은 궁합이 잘 맞았다.

### 시장 지배자 리덕스의 등장

- 리덕스는 Flux에서 Elm 아키텍처를 도입한 라이브러리이다.
- Elm은 웹페이지를 선언적으로 작성하기 위한 언어이다.
    - model: 어플리케이션의 상태를 의미한다
    - view: 모델을 표현하는 HTML이다
    - 업데이트: 모델을 수정하는 방식이다.
- Elm은 Flux와 마찬가지로 데이터 흐름을 세 가지로 분류하고 이를 단방향으로 강제하여 안정적으로 관리하고자 했다.
- 리덕스는 props drilling을 막을 수 있었고 스토어가 필요한 컴포넌트는 단지 connect만 쓰면 되기에 편리했다.
- 하지만 상태를 바꾸기 위해서 너무 많은 보일러 플레이트가 필요했다.

### Context API와 useContext

- 리덕스가 존재하더라도 단순 상태 참조를 위해 사용한다면 준비해야하는 보일러플레이트가 부담스러웠다.
- 리액트 16.3에서는 전역상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 출시했다.
- Context API로 Context Provider가 주입하는 상태를 원하는 곳에서 사용할 수 있었다.
- 이전에도 context가 존재하였고 이를 다루기 위해 getChildContext를 제공했었다. 그러나 상위 컴포넌트가 렌더링 되면 shouldComponentUpdate가 true를 반환해 불필요하게 렌더링이 일어난다는 단점이 있었고 context와의 결합도도 증가하였다.
- 하지만 ContextAPI는 상태관리가 아닌 주입을 도와주는 기능이며, 렌더링 방지기능 까지 존재하지 않아 사용에 주의가 필요하다.

### 훅의 탄생, 그리고 React Query와 SWR

- 16.8 버전에서 훅이 생기면서 state의 관리가 편해졌고 이로 인해 React query와 SWR이 등장했다.
- 두 라이브러리 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리지만, API 호출에대한 상태를 관리하고 있기에 HTTP 요청에 특화되어 있다

### Recoil, Zustand, Jotai, Valtio에 이르기 까지

- 훅을 활용하여 상태를 관리할 수 있는 다양한 라이브러리가 등장한다.
- 리덕스와의 차이점은 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다.

## 5.2 리액트 훅으로 시작하는 상태관리

- 과거에는 리액트와 리덕스는 함께 설치돼 있는것을 볼 수 있었고 업계 표준으로 여기기도 했다
- 그러나, 현재는 Context API, useReducer, useState의 등장으로 컴포넌트에 걸쳐서 재사용하고 리덕스 외의 다른 상태 관리 라이브러리를 선택하는 경우도 많아지고 있다.

### 5.2.1 가장 기본적인 방법: useState와 useReducer

- useState의 등장으로 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있다.
- useReducer 또한 마찬가지로 지역상태를 관리할 수 있는 훅이다. 사실 useState는 useReducer로 구현되어있다.
- 두 훅 모두 지역상태를 관리하기 위한 훅이다.
- 하나의 커스텀 훅에 대한 상태를 두 컴포넌트가 사용하기 위해서는 부모에서 선언을 한뒤 내려주는 방식으로 사용해야 한다.

### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

- useState는 리액트가 만든 클로저 내부에서 관리되어 지역상태로 관리되기에 컴포넌트 내에서만 사용할 수 있다.
- 업데이트 되는 값을 가져오려면 상태를 업데이트 하는 것 뿐 아니라 상태가 업데이트 됐을때 컴포넌트에 반영시키기 위한 리렌더링이 필요한다.
- store를 만드는 createStore는 자신이 관리해야하는 상태를 내부 변수로 가진다음 get 함수로 해당 변수의 최신값을 제공하며, set 함수로 내부 변수를 최신화 하며, 이 과정에서 등록된 콜백을 모조리 실행하는 구조를 띈다.
- 이렇게 createStroe로 만들어진 store의 값을 참조하고 값의 변화에 따라 렌더링을 유도할 훅이 필요한데 useStore로 정의한다.
- useStore는 인수로 store를 받고 이 스토어의 값을 초기화 하는 state를 만든다. useEffect에는 setState (store.get()) 함수를 subscribe로 등록해 두고 값이 변경되면 setState를 실행, unmount 할경우 unscribe을 한다.
- 예제에서 보여준 기본적인 전역상태 관리에서 useStore훅에서 변경 감지가 필요한 값만 setState를 호출하여 객체 상태에 대한 불필요한 리렌더링을 막을 수 있다.
- useStoreSelector는 두번째 인자로 selector라는 함수를 받아서 필요한 값에 대한 변경만 렌더링이 발생한다.
- 하지만 selector가 렌더링시 매번 초기화 되는것을 방지해야 subscribe이 반복해서 수행되지 않는다.
- 이러한 useStoreSelector 훅은 useSubscription 리액트 훅으로 사용될 수 있다.

### 5.2.3 useState와 Context를 동시에 사용해 보기

- useStoreSelector 훅을 활용해 useState로 관리하지 않는 외부 상태값을 읽고 리렌더링까지 발생하는 라이브러리 처럼 사용했었다.
- 하지만 이 훅과 스토어를 사용하는 구조는 반드시 하나의 스토어만 가지게 된다.
- 하나의 스토어를 가지면 전역변수 처럼 작동하게 되어 동일한 형태의 여러 스토어를 가질 수 없다.
- 이를 해결하기 위해 createStore를 이용해 동일한 타입으로 스토어를 여러개 만드는 것이다.
    - 이 방법 또한 의존적인 1:1 관계를 맺고 있어 useStore와 같은 훅을 동일한 개수로 생성해야 한다.
- 이 문제를 해결하는 좋은 방법은 리액트의 Context를 사용하여 주입을 하자
- 이 Context를 사용하기 위해서는 Provider를 정의해야 하는데 불필요하게 렌더링 되는것을 막기 위해useRef를 사용한다
- 결국 Context를 잘 격리하여 필요에 맞게 전역상태를 관리하자

### 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

- Recoil과 Jotai는 Context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는데 초점을 맞춘다.
- Zustand는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리이다.

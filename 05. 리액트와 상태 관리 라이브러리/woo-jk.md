# 5.1 상태 관리는 왜 필요한가?

- 웹 앱에서의 상태는 어떠한 의미를 지닌 값이며, 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.
- 상태로 분류될 수 있는 값은 다음과 같다.
    - UI, URL, 폼, 서버에서 가져온 값
- 과거엔 단순히 서버에서 요청받은 내용을 보여주기만 하면 됐지만, 현대 웹 서비스에선 다양한 기능들이 제공됨에 따라 웹 내부에서 관리해야 할 상태도 점차 비례해서 증가한다.

## 5.1.1 리액트 상태 관리의 역사

- 리액트는 앵귤러와 같은 프레임워크와는 달리, 단순히 사용자 인터페이스를 만들기 위한 라이브러리일 뿐이다.
- 따라서 상태를 관리하는 방법도 개발자에 따라, 시간에 따라 많은 차이가 있다.

### Flux 패턴의 등장

- 페이스북 팀은 리액트의 등장과 비슷한 시기에 Flux 라는 라이브러리를 소개했다.
- 웹 앱이 비대해지고 상태도 많아짐에 따라 상태의 변화 추적이 매우 어려웠는데, 페이스북 팀은 이 문제의 원인을 양방향 데이터 바인딩으로 봤다.
- 그렇기 때문에 단방향 데이터 흐름인 Flux 패턴을 제안했다.
- Flux 패턴에 대한 각 용어의 정의는 다음과 같다.
    - 액션: 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
    - 디스패처: 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
    - 스토어: 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있다.
    - 뷰: 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 때, 뷰에서 액션을 호출한다.
- Flux 패턴은 데이터 갱신과 화면 업데이트에 대한 코드를 작성해야 하기 때문에 코드의 양이 많아진다는 단점이 있다.
- 하지만 데이터 흐름을 추적하기 쉽고 코드를 이해하기 수월하다는 장점이 있다.

### 시장 지배자 리덕스의 등장

- 리덕스는 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나이다.
- 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다.
- 리덕스의 등장으로 prop drilling 문제 해결하고, 전역 상태 관리가 수월해졌다. 때문에 Context API가 등장하기 전까지 리액트의 상태 관리에서 매우 중요한 축이었다.
- 하지만 리덕스는 보일러플레이트가 너무 많다는 단점이 있었다.

### Context API와 useContext

- 리액트는 부모의 상태를 자식 컴포넌트에 쓰기위해 prop 내려주기를 사용하는데, 자식 컴포넌트의 깊이가 깊어질수록 불편하다는 단점이있었다.
- 리덕스가 있었긴하지만 단순 상태 참조를 위해 보일러플레이트는 부담스러웠다.
- 이를 위해 Context API를 출시했고, Context API를 사용하면 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게되었다.
- Context API 출시 이전에도 getChildContext()라는 메서드가 있었지만, 렌더링 문제, 컴포넌트 결합도 문제 등의 단점이 있었다.

### 훅의 탄생, 그리고 React Query와 SWR

- 훅 API가 출시된 이후 state와 state에 대한 로직을 매우 쉽게 재사용할 수 있게 되었다.
- 또한 React Query와 SWR과 같은 라이브러리의 등장으로 HTTP 요청에 대한 상태 관리를 더 효율적으로 할 수 있게 되었다.

### Recoil, Zustand, Jotai, Valtio에 이르기까지

- Recoli, Zustand, Jotai, Valtio 등 새로운 상태 관리 라이브러리들은 한 가지 특징이 있다. 바로 훅을 활용해 작은 크기의 상태를 효율적으로 관리할 수 있다는 점이다.
- 이는 기존 전역 상태 관리 패러다임에서 벗어나 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들었다.
- 또한, 훅을 지원함으로써 함수 컴포넌트에서도 쉽게 사용할 수 있다는 장점이 있다.

# 5.2 리액트 훅으로 시작하는 상태 관리

## 5.2.1 가장 기본적인 방법: useState와 useReducer

- useState 혹은 useReducer를 사용한 커스텀 훅을 사용하여 상태 로직을 쉽게 재사용 할 수 있다.
- 그러나 두 훅은 지역 상태를 가지기 때문에 컴포넌트 간에 상태 공유를 위해선 상태 끌어올리기 등의 수고로움을 거쳐야한다.

## 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

- createStore라는 store 생성 함수와 useStore라는 커스텀 훅을 만들어 리액트 외부의 상태를 관리하는 과정을 설명, 설명 내용은 생략
- useSubscription이라는 리액트 훅을 사용하면 useStore와 비슷하게 구현할 수 있다.

## 5.2.3 useState와 Context를 동시에 사용해 보기

- 위에서 만든 createStore와 Context를 조합하여 사용하는 과정을 설명, 마찬가지로 설명 내용은 생략
- Provider의 하위 컴포넌트가 아닌 곳에서 useContext를 쓰면, 해당 Context의 초기값을 가져온다.
- 많은 상태 관리 라이브러리들이 작동하는 방식은 다음과 같이 요약할 수 있다.
    - useState가 가지고 있는 지역 상태라는 한계를 극복하기 위해 외부 어딘가에 상태를 둔다.
    - 이는 컴포넌트의 최상단, 혹은 자바스크립트의 격리된 스코프 등 어딘가일 수 있다.
    - 이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

## 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand

- Recoil과 Jotai는 Context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는데 초점을 맞추고 있다.
- Zustand는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리한다.
    - 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성된다.

### 페이스북이 만든 상태 관리 라이브러리 Recoil

- 리액트에서 훅의 개념으로 상태 관리를 시작한 최초의 라이브러리 중 하나
- 최소 상태 개념은 Atom을 처음 선보이기도 했다.
- 그러나 아직까지 실험 단계이고, 업데이트가 꾸준하지 않다는 점이 가장 큰 단점이다.
- RecoilRoot
    - RecoilRoot를 애플리케이션의 최상단에 선언해 둬야 한다.
    - Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
    - 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값을 변경할 수 있다.
    - 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.
- atom
    - atom은 상태를 나타내는 Recoil의 최소 상태 단위이다.
    - key 값을 필수로 가지며, 키 값은 애플리케이션 내부에서 유일한 값이어야 한다.
- useRecoilValue, useRecoilState
    - atom의 값을 읽어오거나 업데이트하기 위한 훅이다.
    - RecoilRoot(루트 컴포넌트의 Context)가 없다면 에러가 발생한다.
    - 내부 코드에서 사용하는 lodable은 Recoil의 상태값을 가지고 있는 클래스이다.
    - atom의 상태 변화를 구독하고 값이 변경되면 forceUpdate 같은 기법을 통해 리렌더링한다.

### Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai

- 상향식(bottom-up) 접근법을 취하고 있다.
- 리액트 Context의 문제점인 불필요한 리렌더링을 해결하고자 설계되어 있다.
- atom
    - Recoil과 마찬가지로 최소 단위의 상태를 의미한다.
    - Recoil과는 다르게, atom 하나만으로 상태를 만들 수도, 또 이에 파생된 상태를 만들 수도 있다.
    - Recoil과는 다르게 key 값 설정이 필수가 아니다.
        - 자바스크립트의 WeakMap을 사용해 별도의 key를 받지 않아도 객체 자체를 키로 활용해 스토어에 값을 저장한다.
    - atom 함수는 config라는 객체를 반환한다.
        - config에는 초기값을 의미하는 init, 값을 가져오는 read, 값을 설정하는 write가 존재한다.
        - atom에 따로 상태를 저장하고 있지않다. (useAtomValue를 보면 상태를 어디에 저장하는지 알 수 있다)
- useAtomValue
    - atom의 상태를 가져오는 함수이다.
    - Jotai에서 상태를 저장하는 법
        - 컴포넌트 루트 레벨에서 Context 선언이 없어도 된다. Context가 없다면 Provider가 없는 형태로 기본 스토어를 루트에 생성하고 이를 활용해 값을 저장한다.
        - 물론, Jotai에서 제공하는 Provider를 사용하면 각 상태의 스코프를 지정할 수 있다.
- 특징
    - Recoil에서 영감을 받은 만큼, Recoil과 유사한 면이 많이 보임과 동시에 Recoil이 가지고 있는 몇 가지 한계점을 극복하고있다.
    - Recoil의 atom 개념을 도입했고, API가 매우 간결하다.
    - Recoil과 달리 키를 별도로 관리하지 않아도 된다.
    - 또한, selector가 필요없고 atom만으로도 파생상태를 관리할 수 있다.
    - 정식 버전이 출시되었고, 업데이트가 비교적 활발하여 많은 개발자들이 Recoil 대체용으로 사용하고있다.

### 작고 빠르며 확장에도 유연한 Zustand

- Zustand는 리덕스에 영감을 받아 만들어졌다.
- 하나의 스토어를 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리하고 있다.
- 핵심 기능(createStore)에 대한 코드는 프레임워크에 종속되지 않고, 바닐라 자바스크립트에서도 사용이 가능하다.
- 리액트에서는 useStore라는 훅을 통해 스토어에 대한 접근과 업데이트에 따른 리렌더링을 수행할 수 있다.
- 또한, create 함수를 통해 리액트에서 더 간단하게 스토어를 만들고 사용할 수 있다.
- 특징
    - 많은 코드를 사용하지 않더라도 빠르게 스토어를 만들고 사용할 수 있다.
        
        
        - API가 복잡하지 않고 사용이 간단해 쉽게 접근할 수 있다.
    - 라이브러리의 번들 크기가 다른 라이브러리들 보다 작다.
    - 리덕스와 마찬가지로 미들웨어를 지원한다.

## 5.2.5 정리

- 앞서 소개한 라이브러리 외에도 많은 라이브러리들이 있다.
- 각 라이브러리 별로 상태를 관리하는 방식에는 차이가 있지만, 리액트에서 리렌더링을 만드는 방법은 모두 거의 비슷하다.
- 메인테이너가 많고 다운로드가 활발하며 이슈 관리가 잘되는 라이브러리를 선택하는 것이 좋다.
    - 리액트는 계속 업데이트 되고 있기 때문에, 이 업데이트에 잘 대응해주는 라이브러리를 사용해야 추후 걸림돌이 되지 않는다.
